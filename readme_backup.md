# 汇总

## Redis

1.  Redis为什么快。Redis是否单线程（单IO线程，新版本支持多线程）
Redis的速度非常快，主要有以下几个原因：

    -  **完全基于内存操作**：Redis是一个内存数据库，所有的数据都存储在内存中。相比于传统的磁盘数据库，内存的读写速度要快几个数量级。
    -  **高效的数据结构**：Redis为不同的数据类型（如字符串、哈希、列表、集合、有序集合）设计了专门且高效的数据结构，使得数据操作非常迅速。
    -  **单线程模型**：Redis的核心网络模型是单线程的。这避免了多线程环境下不必要的上下文切换和锁竞争带来的性能开销。因为CPU不是Redis的瓶颈，其瓶颈通常在内存和网络I/O。
    -  **I/O多路复用**：Redis使用I/O多路复用技术（如epoll）来处理大量的客户端连接。它将所有连接的I/O事件都放在一个队列中，用一个线程来处理，从而实现了高并发。

    准确来说：

    *   **核心网络处理是单线程的**：Redis处理客户端命令的请求和执行部分是单线程的。这就是我们通常说“Redis是单线程”的由来。
    *   **新版本引入了多线程**：从Redis 6.0开始，引入了多线程来处理网络I/O的读写和协议解析部分，以提高网络I/O的性能，但命令的执行依然是单线程的。这可以充分利用多核CPU的优势来处理网络请求，进一步提升整体性能。

    所以，简单地回答“单线程”或“多线程”都不完全准确。一个更好的回答是：**Redis的核心命令执行是单线程的，但在新版本中引入了多线程来优化网络I/O。**

2.  Redis的八种基本数据结构，原理和使用场景
    Redis直接暴露给用户的是5种基本数据类型（String, List, Hash, Set, ZSet）和一些扩展类型（如Bitmap, HyperLogLog, Geo, Stream）。这些类型的底层实现依赖于更基础的数据结构。我们这里主要讨论这些核心的底层数据结构。
    - 字符串（String）：底层实现是简单动态字符串（SDS），是一个动态的字符数组，支持修改和增长。存储了字符串长度，空间预分配，避免了频繁的内存分配和释放。
    - 哈希（Hash）：底层实现是哈希表（Hash Table），用于存储键值对。采用链式哈希解决哈希冲突，每个哈希桶存储一个链表，链表节点存储键值对。
    - 列表（List）：底层实现是双向链表（Doubly Linked List），支持在头部和尾部进行快速插入和删除操作。
    - 集合（Set）：底层实现是哈希表（Hash Table），用于存储唯一的元素。
    - 有序集合（ZSet）：底层实现是跳表（Skip List）和哈希表（Hash Table）的组合，用于存储有序的元素。跳表用于快速定位元素，哈希表用于存储元素的额外信息（如分数）。

    还有一些扩展类型：
    - Bitmap：用于存储二进制位的数组，支持位操作。
    - HyperLogLog：用于估计集合的基数（不重复元素的数量）。
    - Geo：用于存储地理位置信息，支持距离计算和范围查询。
    - Stream：用于存储和处理有序的事件流。

3.  Redis持久化，AOF的刷盘时机，RDB的bgsave具体流程
    Redis的持久化有两种方式：AOF和RDB。
    - AOF：Append Only File，追加只写文件。Redis将所有写命令追加到一个文件中，当需要恢复数据时，按照顺序执行这些命令。AOF提供三种刷盘时机：
        - 每次写命令后刷盘：每次写命令后立即将命令追加到AOF文件中，确保数据的实时持久化，但是性能会受到影响。
        - 每秒刷盘一次：每秒将写命令追加到AOF文件中，平衡了性能和数据安全性。
        - 由操作系统决定：由操作系统决定何时将写命令追加到AOF文件中，性能最佳，但数据安全性较低。
        - 优势：持久化数据更加完整，因为AOF记录了所有的写命令，所以可以在发生故障时丢失的数据更少。
        - 劣势：AOF文件会不断增长，恢复数据的速度会变慢。
    - RDB：Redis Database，Redis数据库文件。RDB是将Redis内存中的数据快照保存到磁盘上的一个二进制文件。可以手动触发bgsave，也可以配置自动触发。
        - 优势：RDB文件是一个二进制文件，恢复数据的速度快。
        - 劣势：RDB文件记录的是某个时间点的快照，所以在发生故障时可能会丢失部分数据。
        - bgsave是Redis的一个命令，用于异步地将内存中的数据快照保存到磁盘上的RDB文件中。同样还有一个命令是save，它是同步的，会阻塞Redis的其他操作。
        - bgsave的具体流程：
            1. **创建子进程**：Redis fork一个子进程，子进程负责持久化操作，父进程继续处理客户端请求，保证服务的高可用性。
            2. **生成快照**：子进程将内存中的数据快照保存到一个临时的RDB文件中。
            3. **替换旧文件**：当子进程完成保存后，用临时文件替换原来的RDB文件。
            4. **通知父进程**：父进程收到子进程的通知，更新相关的统计信息，如RDB文件的大小、上次保存的时间等。
    生产环境一般采用结合AOF和RDB的方式，AOF记录所有的写命令，RDB记录某个时间点的快照，两者结合起来可以最大程度地保证数据的安全性和恢复速度。

4.  Redis内存淘汰策略，LRU，LFU具体怎么实现的
    - LRU（Least Recently Used）：最近最少使用算法，根据数据的最近访问时间来判断哪些数据是最近使用的，将最近最少使用的数据淘汰。Redis使用的是近似LRU算法，每次随机采样一部分数据进行LRU淘汰。基于内存和性能的考量，只使用了hash表缓存数据并没有专门针对LRU算法的双向链表。底层数据结构使用了lru字段来维护数据最近一次访问的LRU时钟，每次key被访问时会更新该字段值。这种做法有一定缺陷，仅关注最近一次访问时间，没有考虑到数据的访问频率。
    - LFU（Least Frequently Used）：最近最少使用频率算法，根据数据的访问频率来判断哪些数据是最近使用的，将最近最少使用频率的数据淘汰。具体实现也是随机采样一部分数据进行LFU淘汰。采用hash表+双向链表的结构，数据在双向链表内按照热度值排序。热度值复用lru字段，将访问频率作为lru字段的低8位。
    - 随机淘汰：随机选择一个数据进行淘汰。
    - 不淘汰：不进行任何淘汰，当内存满时直接返回错误。
    - 内存淘汰策略的配置：当内存达到了maxmemory的阈值时，Redis会根据maxmemory-policy配置项来进行内存淘汰。默认是volatile-lru，即当内存满时，根据LRU算法淘汰最近最少使用的数据。

5.  Redis过期策略，定期删除和惰性删除的细节
    Redis的过期策略用于管理键的生命周期，确保过期的键能够被及时删除，释放内存空间。Redis的过期策略有两种：定期删除和惰性删除。
    - 定期删除：Redis会定时扫描过期的key，并删除它们。使用后台线程+随机采样的方式定期执行过期key的检查和删除。优点是及时删除过期的key，释放内存空间。缺点是会占用CPU资源，需要合理配置扫描频率和数量。
    - 惰性删除：当访问一个key时，会判断它是否过期，如果过期了就会删除它。如果过期的key很多，会占用很多内存。优点是不会主动占用CPU检查，缺点是过期的key如果一直不被访问，可能会一直占用内存。
    -  定时删除：在设置键过期时间的同时，也会为该键创建一个定时器，当定时器到期时，会立即删除该键。优点是及时删除过期的key，释放内存空间。缺点是会占用CPU资源可能会影响Redis的性能，需要合理配置扫描频率和数量。


    - 过期key的删除策略的选择：
        - 如果对数据的访问频率比较高，建议使用惰性删除策略，因为定期删除策略会阻塞Redis的其他操作。
        - 如果对数据的访问频率比较低，建议使用定期删除策略，因为惰性删除策略会占用很多内存。

6.  Redis主从集群和哨兵模式的原理
    目前实现Redis高可用的模式有三种：主从同步、哨兵模式和分片集群模式。
    - 主从同步：Redis主从同步是指多个Redis节点之间通过复制（replication）机制实现数据同步和备份。提高系统的可用性和读写性能，是分担Redis读写压力、保证高可用的重要手段。其中，一个节点作为主节点（master），负责接收客户端的写请求和执行写操作；其他节点作为从节点（slave），负责复制主节点的数据和执行读操作。主从集群的原理是通过将主节点的写操作记录到AOF日志中，然后从节点通过读取AOF日志并执行其中的写操作来实现数据同步。
    - 哨兵模式：Redis哨兵模式是指多个Redis节点之间通过哨兵（sentinel）机制实现自动故障转移和监控。其中，多个哨兵节点负责监控主节点的状态和从节点的状态，并在主节点故障时自动将一个从节点升级为新的主节点，确保系统的高可用性。哨兵模式的原理是通过多个哨兵节点之间的通信和投票机制来实现自动故障转移。

7.  分片集群模式的原理，Gossip协议
    - 分片集群模式：Redis分片集群模式是指将Redis数据分布到多个节点上，每个节点负责存储一部分数据。通过分片集群模式，可以实现数据的水平扩展和负载均衡。
    - Gossip协议：Gossip协议是一种用于节点之间通信的协议，用于节点之间的发现、同步和协调。在分片集群模式中，Gossip协议用于节点之间的发现和同步分片信息。
    - 分片集群模式的原理：
        1. **数据分片**：将Redis数据分片到多个节点上，每个节点负责存储一部分数据。
        2. **路由计算**：根据key的哈希值计算出key应该存储在哪个节点上。
        3. **数据同步**：当一个节点的数据发生变化时，通过Gossip协议将数据同步到其他节点上。
        4. **数据读取**：当读取一个key时，根据key的哈希值计算出key应该存储在哪个节点上，然后从该节点上读取数据。
        5. **数据写入**：当写入一个key时，根据key的哈希值计算出key应该存储在哪个节点上，然后将数据写入该节点。
8.  缓存穿透，缓存雪崩，缓存击穿及对应的应对策略
    - 缓存穿透：缓存穿透是指查询一个不存在的数据，由于缓存没有命中，导致每次查询都要去数据库查询，从而导致数据库压力增大。应对策略包括：布隆过滤器：在缓存层之前加布隆过滤器，快速判断数据是否存在；缓存空值：对查询结果为空的数据也在缓存中存储一个空值，设置较短过期时间；参数校验：对请求参数进行合法性校验，过滤明显非法的请求
    - 缓存雪崩：缓存雪崩是指在缓存中存储的大量数据在同一时间过期，导致所有请求都去查询数据库，从而导致数据库压力增大。可能会出现在：缓存服务器宕机；大量缓存设置相同的过期时间；缓存预热不足的场景。应对策略：过期时间随机化；多级缓存；服务降级。
    - 缓存击穿：缓存击穿是指查询一个非常热点的数据，由于缓存没有命中，导致每次查询都要去数据库查询，从而导致数据库压力增大。应对策略是设置热点数据永不过期；双缓存做备份，当热点数据缓存过期时，从备份缓存中读取数据。


9.  Redis的大Key，热Key如何应对
    - 大Key：大Key是指一个Key对应的值占用的内存空间很大，例如一个Hash类型的Key对应的值占用了100MB的内存空间。
        + 可以通过redis-cli --bigkeys命令扫描大Key
        + 可能会造成阻塞Redis主线程，性能下降
        + 解决方法
            - 数据结构优化，避免存储数据信息冗余
            - 压缩数据，例如使用压缩算法（如Snappy、Zlib）压缩数据，减少内存占用
    - 热Key：热Key是指一个Key被访问的频率很高，例如一个Hash类型的Key被访问的频率很高。热Key会导致Redis的性能下降，影响Redis的响应时间。应对策略是将热Key缓存到内存中，避免每次访问都去查询数据库。
        + 可以通过redis-cli --hotkeys命令扫描热Key
        + 可能会导致Redis单节点CPU使用率过高，响应变慢
        + 解决方法
            - 本地缓存
            - 热key复制；热key预加载
            - 读写分离

10. Redis是如何实现事务的
    - Redis事务的实现是通过MULTI、EXEC、DISCARD和WATCH命令来实现的。
    - MULTI命令：用于开启一个事务，为该客户端设置事务状态标志，后续的命令不会立即执行，而是被加入到事务队列中。
    - EXEC命令：按顺序执行事务队列中的所有命令。如果命令执行出错，该命令会失败，但事务不会回滚。其他命令会继续执行。
    - DISCARD命令：用于取消事务，清空事务队列。
    - WATCH命令：用于监控一个或多个键，如果在事务执行前有其他客户端修改了这些键，事务将被取消。

    - Redis事务不支持回滚：错误不会导致整个事务回滚。
    - 性能高但功能简单：适合简单场景

11. Redis实现分布式锁
    - 分布式锁：分布式锁是指在分布式系统中，多个进程或线程在不同的节点上同时访问共享资源时，需要协调它们的访问顺序，避免冲突。
    - 实现分布式锁的方式有很多种，其中比较常用的是基于Redis的分布式锁。基于Redis的分布式锁的实现原理是利用Redis的setnx命令（set if not exists），当多个进程或线程同时执行setnx命令时，只有一个进程或线程能够成功执行，其他进程或线程会失败。成功执行的进程或线程可以认为是获得了分布式锁，其他进程或线程可以等待或重试。
    - 基于Redis的分布式锁的实现方式有很多种，例如通过lua脚本实现分布式锁，通过redlock算法实现分布式锁等。
    - 基于lua脚本实现分布式锁的原理是利用Redis的eval命令执行Lua脚本，在脚本中判断锁是否存在，如果不存在则设置锁并返回成功，否则返回失败。
        - 脚本如下：
        ```
        local lockKey = KEYS[1]
        local clientId = ARGV[1]
        local expireTime = ARGV[2]
        local result = redis.call("SET", lockKey, clientId, "NX", "EX", expireTime)
        if result then
            return 1
        else
            return 0
        end
        ```
        - 获取锁的时候，会执行一段lua脚本，调用redis的setnx命令，当锁不存在时加锁，设置锁的key和value，过期时间为锁的超时时间。如果加锁失败，说明锁已经被其他进程或线程获得，返回失败。
        - 释放锁的时候，会执行一段lua脚本，调用redis的del命令，通过比较锁的value是否与客户端的value相等，相等则删除锁，否则不删除。
        - lua脚本执行是原子性的，不会被其他进程或线程中断，确保了锁的获取、释放是安全的。

    - 基于redlock算法实现分布式锁的原理是利用多个Redis节点同时设置锁，只有当大多数节点都设置成功时，才认为获得了分布式锁。
    - redlock算法的实现步骤：
        1. 客户端向多个Redis节点发送SET命令，设置锁的key和value，过期时间为锁的超时时间。
        2. 客户端收到大多数节点的回复后，判断是否获得了锁。如果获得了锁，客户端返回成功；如果没有获得锁，客户端向所有节点发送DEL命令，删除所有设置的锁。
        3. 客户端根据返回结果判断是否获得了锁。如果获得了锁，客户端执行业务逻辑；如果没有获得锁，客户端等待一段时间后重试。
        4. 客户端在业务逻辑执行完成后，向所有节点发送DEL命令，删除锁。

### 刁钻问题

1.  如果Redis主从架构下，使用惰性删除时，从节点的key已经到期了，读从节点时会怎么样
    - 当从节点读取一个过期的key时，从节点会检查key是否过期，如果过期了就会像主节点一样执行惰性删除：删除该key并返回一个空值（null）给客户端。
    - 但从节点不会向主节点或其他从节点同步删除该key的命令，因为从节点的key过期时间是从主节点同步过来的，主节点不会主动通知从节点删除key。
    - 从节点的key过期时间是从主节点同步过来的，主节点会在key过期时向所有从节点发送一个DEL命令，从节点会在收到DEL命令后执行惰性删除。
    - 如果主从复制延迟很大，从节点在读取时读取到过期的key.
    **总结**：在Redis主从架构中使用惰性删除时，读取从节点不会返回已过期键（3.2+版本），从节点会本地检查并删除，但真正的同步删除由主节点负责。这设计确保了数据一致性和读取安全性。

2.  Redis的Hash数据结构在扩容时是如何渐进式扩容的，如果某个Key一直不被访问，可以顺利扩容吗
    - 首先Redis的Hash使用了hash表作为基本的存储结构，每个字典/Hash结构由两个哈希表组成，每个哈希表中存储了其节点数组、大小等。其中新表是在扩容时新建的。
    - 当哈希表的负载因子超过阈值时，会触发渐进式扩容，进行rehash操作。
    - 每次对字典的操作（增删改查）都会触发迁移ht[0]中的一个桶到ht[1]中。
    - 迁移完成后，会将ht[1]设置为ht[0]，并且释放旧表。
    - Redis也会通过定时任务确保即使没有对字典进行操作，也会渐进式地迁移桶到新表中。
    - 如果某个Key一直不被访问，也是可以顺利扩容的，Redis中的渐进式rehash操作只要字典中其他元素有任何操作，都会被触发，另外，每次搬迁都是桶级别的，跟单个元素无关。而且还会有定时任务来兜底。

3.  Redis分片集群扩容的过程是怎么样，客户端请求如何重定向的，Redis的slot模式和一致性哈希有哪些区别

---

## MySQL

1.  Mysql为什么用B+树，B+树和B树，红黑树等有什么区别
2.  Varchar和Char
3.  InnoDB和Myisam的区别
4.  Mysql索引的数据结构和原理，索引优化，索引失效的条件，索引下推
5.  数据库Join的原理（Nested Join, Nested index Join, Hash Join等）
6.  redo log的作用，buffer pool的原理，redo log刷盘的时机，redo log满了怎么办处理，为什么用redo log而不是bin log恢复数据
7.  redo log, undo log, bin log的原理和作用
8.  4个隔离级别的原理，分别怎么实现的。MVCC的原理，next-key-lock如何解决幻读（有没有例外情况）
9.  行锁，表锁，意向锁
10. 主从架构的各种问题（主从延迟的解决方法，缓存一致性问题）
11. 读写分离，分库分表
12. 深分页优化方案
13. 冷热分离方案
14. 间隙锁死锁的解决方法

---

## JAVA

1.  Equals,hashcode方法，equals方法满足哪些特性，hashcode用在了哪些地方，Hashmap中的hashcode怎么用的
2.  线程池的参数，有哪些线程池类型，线程池的各种抛弃策略适合哪些场景，线程池的原理
3.  Thredlocal的原理，为什么容易内存泄漏
4.  Syschronized和Lock的区别，AQS的原理，volatile
5.  JVM的原理，垃圾回收，分代收集的算法，各种问题怎么排查（频繁Full GC，内存占用大，OOM等），JVM各种参数的优化。
6.  CMS, Parralel, G1等垃圾回收器的原理
7.  JAVA类加载的过程与这样做的原因，有没有办法打破双亲委派，Class这个类在哪一块区域
8.  Spring中Bean的生命周期，Spring MVC的流程，Spring IOC和AOP的原理，为什么动态代理必须基于接口？
9.  各种Collection的原理，Hashmap，Hashtable，ArrayList，LinkedList，Hashset，Treemap，ConcurrentHashMap（重点，扩容机制，写入机制，新旧版本对比（阻塞队列等））
10. String, StringBuffer, StringBuilder的区别，String不可变有什么好处？
11. NIO, BIO, AIO
12. 虚拟线程

### 刁钻问题

1.  设计一个JVM监控程序，你应该关注哪些指标，怎样设计？


2.  equals方法满足哪些特性，有没有可能 a.equals(b)是true，但是b.equals(a)是false
3.  ConcurrentHashmap的扩容机制，如果某些块或者者桶一直不被访问，能扩容成功吗

---

## 操作系统/网络 高频问题

1.  虚拟地址，内存管理等方式
2.  Linux常用命令
3.  进程，线程，协程的各种概念
4.  各种IO, select, poll, epoll, 零拷贝之类的
5.  死锁，死锁检测，死锁恢复，死锁防止
6.  什么是操作系统，用户态内核态，系统调用的概念
7.  进程，线程之间通信的方式
8.  内存管理，分页分段等
9.  TCP, UDP
10. 输入一个URL到渲染完成经过了哪些过程
11. HTTP1.0, 1.1, 2.0, 3.0分别有哪些特性
12. HTTPS的基本概念和流程
13. Cookie, Session和JWT的各种概念

## Kafka

1.  Kafka如何保证的高吞吐（顺序写磁盘，零拷贝，批量写）
2.  Kafka的架构（producer, broker, consumer group, partition的主从机制等）
3.  Kafka如何保证消息的顺序
4.  如何保证消息不丢失（ACK机制），如何保证消息不被漏消费或者多消费（幂等性的角度）
5.  如何合理设置partition的数量
6.  Kafka的rebalance，如何避免
7.  Kafka在新版本Kraft架构下和旧版ZK架构的区别
8.  Kafka如何选出Controller和各个分区的leader
9.  高水位和低水位机制
10. 事务是如何保证的
11. 如何处理消息堆积
12. 和其他消息队列的差别
13. raft协议的各种细节（为什么要选举超时，如何避免频繁选举，WAL等）

## Zookeeper

1.  基本概念，临时节点，顺序节点，永久节点等
2.  ZAB协议的流程，ZAB协议和raft协议的区别
3.  基于ZK的系统如何选主
4.  如何实现服务注册，配置中心等
5.  如果某一个worker挂了，会对系统有什么影响，如何防止这种情况（woker挂了导致某次任务太慢）。如果coordinater挂了会怎么样选举。
6.  CAP，BASE理论

## 场景

1.  如何实现延时队列（redis zset或者时间轮的方式）
2.  限流的各种方法，如何用redis zset实现滑动窗口限流，如何用redis实现令牌桶限流
3.  如何设计一个通知系统，能够满足不同部门要求的各种通知类型（邮件，短信，电话等方式）
4.  在几千万用户的情况下，如何用redis快速查询单个用户的消费排名
5.  如何实现一个一百亿数据量，100万QPS的短URL系统，且能够统计每个URL被访问的次数和访问次数最多的100个URL
6.  用JAVA代码实现一个缓存系统，并且其中的key可以设置过期时间
7.  用JAVA代码实现一个模拟线程池，如果线程数小于核心线程数，就执行，否则等待
8.  用JAVA实现多个线程交替按顺序打印数字
9.  实现一个消息队列，支持push，pop，且生产者
6.  用JAVA代码实现一个缓存系统，并且其中的key可以设置过期时间
7.  用JAVA代码实现一个模拟线程池，如果线程数小于核心线程数，就执行，否则等待
8.  用JAVA实现多个线程交替按顺序打印数字
9.  实现一个消息队列，支持push，pop，且生产者能够向多个队列里push消息，且能够感知消费者的消费进度
10. 实现LRU缓存，在内存满了后能够淘汰最后一个
11. 用基本数据结构实现JAVA ArrayList
12. 实现feed流系统，高并发低延迟
13. 设计高并发秒杀系统
14. 设计高并发低延时实时弹幕系统
15. 单点登录系统如何设计
16. 分布式事务，以及如何保证分布式微服务场景下的数据一致性（库存，订单最终一致）
17. 在mysql+redis的结构下，如何保证缓存和数据库的一致性
18. 如何设计一个跨Region的服务注册系统，保证低延时等
19. 用redis如何实现分布式锁，要注意哪些事项，redlock有什么硬伤
20. 用zookeeper如何实现分布式锁
21. 分布式id相关的问题，如何设计分布式id系统，雪花算法如何应对时钟回拨
22. 让你设计一个rpc框架，你会怎么设计
23. 让你设计一个消息中间件，你会怎么设计
