1. RocketMq有什么优缺点？
    - 可用性非常高，能保障消息可靠性，功能较为完善，在稳定性上更值得信赖
    - 缺点是支持的客户端语言不是很多
2. 谈谈你对RocketMQ的理解
    RocketMQ是阿里巴巴开源的一款分布式消息中间件，具有高吞吐量、低延迟和高可用性。主要组件包括生产者、消费者、Broker、Topic和队列。消息由生产者发送到Broker，再根据路由规则存储到队列中，消费者从队列中拉取消息进行处理。适用于异步解耦的业务场景。

    消息队列有两种消息模型：队列模型 和 发布/订阅模型
    - 队列模型：生产者往某个队列中发送消息，一个队列可以存储多个生产者消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，每条消息只能被一个消费者消费。
    - 发布/订阅模型：一份消息发送给多个消费者，并且每个消费者都要求收到全量的消息。发布者将消息发送到指定topic，消费者如果想接收消息，得先订阅topic，订阅后，订阅者就可以收到该topic的所有消息。
    
    RocketMQ用的就是发布订阅模型。通过使用在一个Topic中配置多个队列并且每个队列维护每个消费者组的消费位置，实现了发布定于模式。

    RocketMQ中的主要概念：
    - Message：消息
    - topic：可以看做消息的归类。
    - tag：可以看做子主题，使用tag可以更灵活支持细粒度的消息类型。
    - group：一个消费者组中包含多个消费者，多个组之间是相互隔离的。
    - Message queue：消息队列，一个topic下可以设置多个消息队列，一个topic下可以设置多个消息队列。
    - offset：在topic的消费过程中，由于消息需要被不同的组多次消费，所以消费完的消息不会立即删除，而是在每个队列中维护一个消费位置，标识消费到的消息位置。

    消息消费模式有两种：clustering（集群消费）和 Broadcasting（广播消费）

    RocketMQ架构由四部分组成：NameServer、Broker、Producer、Consumer，分别对应了发现、存、发、收的功能。每个部分都是集群部署的。

    - NameServer：注册中心。无状态的服务器角色，主要功能：和Broker节点保持长链接；维护topic的路由信息。么个NameServer节点之间相互独立，Producer在发送消息前，从NameServer获取topic的路由信息，知道了发往哪个Broker，Consumer也会定时从NameServer获取topic的路由信息，Broker也会注册到NameServer，定时进行心跳连接，定时同步维护的topic到NameServer。

    - Broker：消息存储和中转角色，负责存储和转发消息。其内部维护者一个个的Consumer Queue，用来存储消息的索引，而真正存储消息的地方是CommitLog。

    - Producer：消息生产者
    - Consumer：消息消费者

3. 如何保证消息的可用性/可靠性/不丢失呢？

    首先消息可能会在这三个阶段发生丢失的情况：生产、存储、消费

    在生产阶段，可以通过请求确认机制，来保证消息的可靠传递。同步发送时要注意返回的响应结果，同样地异步发送时，也要在回调方法里检查，如果发送失败或者异常，进行异常重试。

    在存储阶段，可以通过配置可靠性优先的Broker参数避免宕机丢消息，

4. 如何解决顺序消费和重复消费？

    RocketMQ中的顺序消费有两层含义：全局顺序和分区顺序（队列内顺序），实际生产中一般都是分区顺序，RocketMQ主要是通过队列和消费者队列锁定来保证顺序。

    在生产端，可以使用顺序消息发送方式，使用MessageQueueSelector搭配业务Key来保证队列内顺序。指定消息发送到某个队列。从而保证队列内的顺序。
    ```
        // 发送时指定队列选择器
            SendResult result = producer.send(msg, new MessageQueueSelector() {
                @Override
                public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
                    // arg 是订单ID
                    int id = (Integer) arg;
                    // 取模选择队列
                    int queueIndex = id % mqs.size();
                    return mqs.get(queueIndex);
                }
            }, orderId); // arg 传入订单ID
    ```

    而在Broker中，队列内的消息是按照发送顺序存储的。

    而顺序消费主要依赖消费者队列锁，实际使用时，通过使用messageListenerOrderly来实现顺序消费，在使用顺序消费监听器时，Broker会锁定队列，保证同一个队列在同一时间只被一个消费者线程消费。从而保证队列内消息顺序的消费。

    而重复消费，RocketMQ本身不能完全避免重复消费，重复消费时分布式消息系统的常态，例如消费失败重新消费，或者网络异常时的重试拉取等。所以解决重复消费主要依赖消费端实现幂等性和一些辅助机制。

    1. 幂等消费，消费逻辑必须能够处理重复消息而不产生副作用。例如通过数据库或缓存记录消息唯一ID，消费前检查是否已处理；通过业务唯一键例如交易号、订单号用作幂等判断，通过数据库处理前先判断是否已插入过等。
    2. 可以利用数据库的主键约束或者缓存记录消息id或者幂等逻辑来保证不出现重复消费。


5. 如何解决消息堆积问题？

    根本原因：生产端发送速度 > 消费端处理的速度。

    最直接的解决方法：扩容，增加消费者实例数，提升并行消费能力。另外考虑增加topic队列数，让实例间能分担压力。

    其次考虑优化消费端：例如检查是否存在消费失败、消费阻塞、业务逻辑慢等问题，或者使用批量消费（consumeMessageBatchMaxSize）或异步消费提升效率；将耗时操作例如写DB、大计算异步化或放到下游处理。

    还以考虑对生产端控制，对生产端限流，避免超出系统处理能力，对非关键消息做降级处理。
    也可以考虑ROcketMQ的特有手段，例如
    - 死信队列：消费者针对某条消息消费失败达到maxConsumTimes后，Broker会把该消息转移到消费者组对应的死信队列。而不是直接丢弃，这样后面可以人工排查/重放。
    - 

6. RocketMQ中的负载均衡

    生产端的负载均衡，Producer会先从NameServer中获取topic下对应的队列列表（broker和queue），默认RocketMQ会在生产端采用轮询的机制，保证消息均匀地分布到多个队列中。
    在消费端，每个consumer在启动时，都会向Broker注册自己，broker会维护一个队列和消费者实例的对应关系,包含订阅关系、消费进度等，broker负责维护这些信息。而队列的分配过程会由消费者完成。消费者会根据配置的策略来决定自己负责哪些队列，同时消费者也会周期性的做一个rebanlance的过程，根据当前实例数和队列数重新计算哪些队列该由我负责，从而实现负载均衡。

